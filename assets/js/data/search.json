[ { "title": "C++20 Concept", "url": "/posts/C++-20-Concept/", "categories": "C++", "tags": "C++", "date": "2024-10-01 00:00:00 +0900", "snippet": "We often come across template code during development. The standard libraries we frequently use are also mostly developed using templates. However, such template code is often used in ways that differ from the developer’s original intention, and it can be difficult to identify the cause when errors occur.Today, I will explain the Concept introduced in C++20 for the first time and discuss why we should use it.#include &amp;lt;iostream&amp;gt;template&amp;lt;typename T&amp;gt;T add(T a, T b){ return a + b;}int main(){ std::cout &amp;lt;&amp;lt; add(5, 3) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add(2.5, 3.3) &amp;lt;&amp;lt; std::endl;}Now, a template function for addition operation on the same types is given. The initial developer of this function wanted it to perform addition only on numeric types such as integers and floats.#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;template&amp;lt;typename T&amp;gt;T add(T a, T b){ return a + b;}int main(){ std::cout &amp;lt;&amp;lt; add(std::string(&quot;Hello, &quot;), std::string(&quot;World&quot;)) &amp;lt;&amp;lt; std::endl; }However, the user of the function used it for string types, which differed from the initial developer’s intention. However, no errors occurred, and the function worked as expected.(In such cases, the user of the function may not realize that they have used the function incorrectly.) In the code above, the add function has no constraints on the type T and simply performs addition on the two argumentsIn this case, the add function not only supports int and float types, but also supports string types that have the + operator. In this case, the function is used differently from the initial developer’s intention, and it may cause errors during the maintenance of the template code. Let’s look at another example.#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;template&amp;lt;typename T&amp;gt;T add(T a, T b){ return a + b;}int main(){ std::cout &amp;lt;&amp;lt; add(std::vector&amp;lt;int&amp;gt;{1, 2}, std::vector&amp;lt;int&amp;gt;{3, 4}) &amp;lt;&amp;lt; std::endl;}Error C2679 binary &#39;&amp;lt;&amp;lt;&#39;: no operator found which takes a right-hand operand of type &#39;T&#39; (or there is no acceptable conversion)This case involves using the std::vector&amp;lt;int&amp;gt; type with an add template function that supports only integer types. This is also a case where the function is used differently from the initial developer’s intention. Fortunately, when using this function with a type that does not have a defined addition operation, such as std::vector, a compilation error occurs, and this allows the user to realize the mistake. However, it can be difficult to immediately identify the cause of the error based solely on the error messagesAs seen in the two examples above, in template metaprogramming, if there are no clear constraints on the types, the code may compile but exhibit unexpected behavior at runtime, or even if a compile-time error occurs, it can be difficult to immediately identify the cause. Concept “Named sets of such requirements are called concepts. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:”https://en.cppreference.com/w/cpp/language/constraintsAccording to the official documentation, the definition of a concept is described as a named set of requirements. C++20’s concepts greatly enhance the safety and clarity of template code. By using concepts, you can declaratively specify the constraints that template arguments must satisfy, which are checked at compile time. This feature helps prevent type-related errors that can occur during template instantiation and assists in conveying the intended use of templates more clearly.Let’s further improve the above example using concepts.#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;concepts&amp;gt;template&amp;lt;typename T&amp;gt;concept Numeric = std::is_arithmetic&amp;lt;T&amp;gt;::value; //concept definitiontemplate&amp;lt;Numeric T&amp;gt; // concept usageT add(T a, T b){ return a + b;}int main(){ std::cout &amp;lt;&amp;lt; add(5, 3) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add(2.5, 3.3) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add(std::string(&quot;Hello, &quot;), std::string(&quot;World&quot;)) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; add(std::vector&amp;lt;int&amp;gt;{1, 2}, std::vector&amp;lt;int&amp;gt;{3, 4}) &amp;lt;&amp;lt; std::endl; }Error (active) E0304 no instance of function template &quot;add&quot; matches the argument list By using concepts, we can present error messages more clearly. Furthermore, it enhances code readability and allows developers to more clearly convey their intentions to users.Concept Definition and Usagetemplate &amp;lt; template-parameter-list &amp;gt;concept [concept name] = [Constraints requires or type traits]The syntax for defining a concept is as described above. Here, we need to pay attention to two keywords, concept and requires, and what type traits are. concept: A keyword used to declare a concept. It allows you to define the name of the concept. requires: The requires keyword is used in two senses: as an expression to evaluate the validity of types where it is used, and as a clause to apply a concept to a template type. A detailed explanation will be provided in the following chapter. type traits: Metafunctions used since C++11 to obtain information about types at compile time or to obtain modified types. Concept Clause To define a concept, use the concept keyword to declare a name and describe the corresponding constraints.template &amp;lt; template-parameter-list &amp;gt;concept concept-name attr ﻿(optional) = constraint-expressionBelow is a defined concept that only applies when the template type is 4 bytestemplate &amp;lt;class T&amp;gt;concept Type4Byte = sizeof(T) == 4;The definition of a concept is simple. Just specify the concept keyword, name, and constraints concept : Keyword for declaring a concept. Type4Byte : Name of concept sizeof(T) == 4 : Constraints of concept#include &amp;lt;iostream&amp;gt;#include &amp;lt;concepts&amp;gt;template &amp;lt;class T&amp;gt;concept Type4Byte = sizeof(T) == 4;template&amp;lt;Type4Byte T&amp;gt;void func(T type) { }int main(){ int i = 4; float f = 12.f; double d = 12.f; func(i); func(f); func(d);}Error C2672 &#39;func&#39;: no matching overloaded function foundAn error message is occurring because there is no overloaded function that matches the double type. Since the double type is 8 bytes in size, the template function was not created, and thus an error occurs when used. By utilizing concepts, constraints can be placed on the template type to prevent misuse by the function user.Concepts cannot recursively refer to themselves and cannot be constrainedtemplate&amp;lt;typename T&amp;gt;concept V = V&amp;lt;T*&amp;gt;; // error: recursive concept template&amp;lt;class T&amp;gt;concept C1 = true;template&amp;lt;C1 T&amp;gt;concept Error1 = true; // Error: C1 T attempts to constrain a concept definitiontemplate&amp;lt;class T&amp;gt; requires C1&amp;lt;T&amp;gt;concept Error2 = true; // Error: the requires clause attempts to constrain a concept Requires Clauses The keyword requires is used to introduce a requires clause, which specifies constraints on template arguments or on a function declaration.The expression must have one of the following forms A primary expression, e.g. Swappable, std::is_integral::value, (std::is_object_v &amp;amp;&amp;amp; ...), or any parenthesized expression. #include &amp;lt;concepts&amp;gt; template &amp;lt;class T&amp;gt; requires std::is_integral&amp;lt;T&amp;gt;::value int Add(T a, T b) { return a + b; } A sequence of primary expressions joined with the operator &amp;amp;&amp;amp;. #include &amp;lt;concepts&amp;gt; #include &amp;lt;type_traits&amp;gt; template &amp;lt;class T&amp;gt; requires std::is_integral&amp;lt;T&amp;gt;::value &amp;amp;&amp;amp; std::is_signed&amp;lt;T&amp;gt;::value int Add(T a, T b) { return a + b; } A sequence of aforementioned expressions joined with the operator ||. #include &amp;lt;concepts&amp;gt; #include &amp;lt;type_traits&amp;gt; template &amp;lt;class T&amp;gt; requires std::is_integral&amp;lt;T&amp;gt;::value || std::is_floating_point&amp;lt;T&amp;gt;::value int Add(T a, T b) { return a + b; } Requires clauses can only use boolean constants that are determined at compile time. Types that can be implicitly cast to bool, such as int and char, cannot be used.template &amp;lt;class T&amp;gt; requires true // This has no effect, but it&#39;s valid to write like this!!void foo(T a) {}template &amp;lt;class T&amp;gt; requires false // This will always return false, so this function can never be usedvoid foo(T t) {}template &amp;lt;class T&amp;gt; requires std::is_pointer_v&amp;lt;T&amp;gt; // Direct use of type trait is possiblevoid foo(T t) {}template &amp;lt;class T&amp;gt; requires 1 // ERROR!! You cannot use an intvoid foo(T t) {}bool check_error() {return true; }template &amp;lt;class T&amp;gt; requires (check_error()) // ERROR!! Not a constexpr function, hence an errorvoid foo(T t) {}constexpr bool check_ok() { return true; }template &amp;lt;class T&amp;gt; requires (check_ok()) // OK since it&#39;s evaluated at compile time due to constexprvoid foo(T t) {}template &amp;lt;class T&amp;gt; requires (sizeof(T) &amp;gt; 4) // Direct use of a constant expression is OKvoid foo(T t) {}template &amp;lt;class T&amp;gt;concept GreaterThan4 = sizeof(T) &amp;gt;= 4;template &amp;lt;class T&amp;gt; requires GreaterThan4&amp;lt;T&amp;gt; // Using a concept is also OKvoid foo(T t) {} Requires Expression requires { requirement-seq; }; // In a requires expression, constraints can be specified without any arguments.requires ( parameter-list ) { requirement-seq; }; // Constraints using parameters are also possible. Simple Requires Expression A simple requires expression, as the name suggests, refers to a basic expression requirement. This expression does not perform actual computations instead, it only determines the syntactic feasibility or infeasibility.template &amp;lt;class T&amp;gt;concept Comparable1 = requires(T a, T b){ a &amp;lt; b; // It does not evaluate whether &#39;a&#39; is less than &#39;b&#39;. It only checks if &#39;a &amp;lt; b&#39; comparison is possible.};template &amp;lt;class T&amp;gt;concept Comparable = requires(T a, T b){ a &amp;lt; b; // It does not evaluate whether &#39;a&#39; is less than &#39;b&#39;. It only checks if &#39;a &amp;lt; b&#39; comparison is possible.};template&amp;lt;Comparable T&amp;gt;bool Compare(T l, T r){ return l &amp;lt; r;}int main(){ Compare(1, 2); // ok Compare(&quot;aa&quot;, &quot;bb&quot;); // ok Compare(&quot;aa&quot;, 123); // error, incompatible types for comparison}The example above does not actually evaluate the values of ‘a’ and ‘b’ to return true or false. Instead, it assesses whether the ‘&amp;lt;’ operation is possible or not between ‘a’ and ‘b’. Compound Requires Expression Compound requires expressions allow for the logical combination of multiple conditions to set more complex and specific constraints on template functions or classes. This enables the clear and efficient expression of complex type constraints, enhancing the type safety of the code.Logical operators AND (&amp;amp;&amp;amp;), OR (||), and NOT (!) are used to combine multiple conditions to verify if the template argument types meet complex requirements through compound requires expressions.#include &amp;lt;iostream&amp;gt;#include &amp;lt;type_traits&amp;gt;// Combines the conditions that the type must be integral and copyabletemplate&amp;lt;typename T&amp;gt;concept CopyableIntegral = std::is_integral_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; std::is_copy_constructible_v&amp;lt;T&amp;gt;;template&amp;lt;typename T&amp;gt;requires CopyableIntegral&amp;lt;T&amp;gt; // Must satisfy CopyableIntegralT add(T a, T b){ return a + b;}int main() { std::cout &amp;lt;&amp;lt; add(5, 10) &amp;lt;&amp;lt; std::endl; // OK, int is integral and copyable // std::cout &amp;lt;&amp;lt; add(5.5, 10.1) &amp;lt;&amp;lt; std::endl; // Error, double is not an integral type}The CopyableIntegral concept is a compound expression that combines std::is_integral_v (whether type T is an integral type) and std::is_copy_constructible_v (whether type T is copyable). Thus, a type T must be both integral and copyable to satisfy this concept. AND Compound(&amp;amp;&amp;amp;) template&amp;lt;typename T&amp;gt; concept ArithmeticAndCopyable = requires(T a, T b) { { a + b } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Addition is possible { a - b } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Subtraction is possible std::is_copy_constructible_v&amp;lt;T&amp;gt;; // Copyable }; template&amp;lt;typename T&amp;gt; requires ArithmeticAndCopyable&amp;lt;T&amp;gt; T calculate(T a, T b) { return (a + b) * (a - b); } Here, the requires clause combines the conditions that type T must be capable of addition and subtraction, and must be copy constructible, using the AND (&amp;amp;&amp;amp;) operator. The template is instantiated only when all conditions are satisfied. OR Compound(||) template&amp;lt;typename T&amp;gt; concept AddableOrMultipliable = requires(T a, T b) { { a + b } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Addition is possible } || requires(T a, T b) { { a * b } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Multiplication is possible }; template&amp;lt;typename T&amp;gt; requires AddableOrMultipliable&amp;lt;T&amp;gt; T operate(T a, T b) { if constexpr (requires { a + b; }) { return a + b; } else { return a * b; } } In this example, the requires clause uses the OR (||) operator to allow the template to be instantiated only if addition or multiplication is possible. NOT Compound (!) template&amp;lt;typename T&amp;gt; concept NotFloatingPoint = !std::is_floating_point_v&amp;lt;T&amp;gt;; template&amp;lt;NotFloatingPoint T&amp;gt; T negate(T a) { return -a; } Here, the requires clause uses the NOT operator (!) to allow the template to be instantiated only if it is not a floating-point type. Nested Requires Expressions Nested Requires Expressions refer to the method in C++ of including other concepts within one concept when using Concepts. This allows for the expression of more complex and detailed type constraints.For example, let’s create a concept that defines a type as “an integral type capable of basic arithmetic operations.” In this case, you can use the std::integral concept from the C++ standard library to check if the type is integral and, additionally, verify if it is capable of basic arithmetic operations.#include &amp;lt;concepts&amp;gt;template &amp;lt;typename T&amp;gt;concept IntegralAndArithmetic = requires(T x, T y) { requires std::integral&amp;lt;T&amp;gt;; // Checks if T is an integral type { x + y } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Addition must be possible { x - y } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Subtraction must be possible { x * y } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Multiplication must be possible { x / y } -&amp;gt; std::same_as&amp;lt;T&amp;gt;; // Division must be possible};int main() { static_assert(IntegralAndArithmetic&amp;lt;int&amp;gt;, &quot;int should satisfy IntegralAndArithmetic&quot;); static_assert(!IntegralAndArithmetic&amp;lt;double&amp;gt;, &quot;double should not satisfy IntegralAndArithmetic&quot;);}This code demonstrates that the int type satisfies the IntegralAndArithmetic concept, but the double type does not. Thus, nested requires expressions allow for the systematic verification of complex conditions for types. Changes Due to the Introduction of Concepts Readability and Declarative Style: Using concept allows you to define type requirements more clearly, making the code easier to read and understand. The code itself serves as documentation. Improved Error Messages: With concept, you can provide clearer error messages that explain the issues more precisely when compilation errors occur, making debugging easier. Code Conciseness: concept reduces the amount of code needed to check type traits, thereby simplifying the code. This helps in enhancing the maintainability of the project. More Powerful Template Tools: concept enables more intuitive type constraints than traditional SFINAE, making template metaprogramming more powerful.In conclusion, the introduction of concept enhances the accessibility of C++ template programming and makes template metaprogramming easier and more efficient. It aids programmers in applying type constraints more easily and in writing more stable and understandable code. Conclusion Today, we explored one of the new features of C++20, the concept, which clarifies the intent of code and reduces the complexity associated with using templates. I hope that your template code becomes more powerful and easier to understand. We will continue to explore other new features of C++ in future posts. See you in the next post! References Features of C++ 20c++20 ConceptC++20 Concepts 완벽 가이드Constraints and concepts (since C++20)" }, { "title": "LeeCode 82. Remove Duplicates from Sorted List II", "url": "/posts/LeeCode-82.-Remove-Duplicates-from-Sorted-List-II/", "categories": "Algorithm", "tags": "Algorithm", "date": "2024-02-03 00:00:00 +0900", "snippet": " Discription Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.Example 1:Input: head = [1,2,3,3,4,4,5]Output: [1,2,5]Example 2:Input: head = [1,1,1,2,3]Output: [2,3]Constraints: The number of nodes in the list is in the range (0, 300). -100 &amp;lt;= Node.val &amp;lt;= 100 The list is guaranteed to be sorted in ascending order. Intuition The intuition of this problem is to remove nodes that have value duplicated in a linked list and reconnect linked list.To solve this problem, you should traverse the linked list and keep track of the starting and ending nodes that do not have duplicated values. Approach The key point in a linked list problem is creating previous node and set previouse node ‘s next node to point to the head node.It is because previous node is requried when you disconnect and reconnect the linked list. Let me show you steps to solve this problem below. Creating previouse node that points to head node. Find starting node with value duplicated. (If the value of the current node is the same as the value of the next node.) Find the next node of ending node with value duplicated.3-1. If there are nodes with value duplicated, remove all nodes with duplicated value and set next node to previous node’s next node.3-2. Otherwise, set current node to previous node. Set next node to current node. Repeat 1~4 until no next node. Solution class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode* dummy = new ListNode(0, head); ListNode* pre = dummy; ListNode* cur = head; while (cur) { auto* next = cur-&amp;gt;next; while (next &amp;amp;&amp;amp; cur-&amp;gt;val == next-&amp;gt;val) { auto* temp = next; next = next-&amp;gt;next; delete temp; } //no nodes that have value duplicated if (cur-&amp;gt;next == next) { pre = cur; } //if there are nodes with value duplicated //need to delete current node because it has same value also. else { delete cur; pre-&amp;gt;next = next; } cur = next; } return dummy-&amp;gt;next; }};As I said above, It is the most important to create previous node in linked list problem. Therefore create a dummy node to point to head and set the pre node to point the dummy node.ListNode* dummy = new ListNode(0, head);ListNode* pre = dummy;ListNode* cur = head;auto* next = cur-&amp;gt;next;while (next &amp;amp;&amp;amp; cur-&amp;gt;val == next-&amp;gt;val){ auto* temp = next; next = next-&amp;gt;next; delete temp;}Compare the value of current node with the value of next node, andif they are equal, delete the memory of next node and set next node to point to the next node of next node to explore the next node. You can see that the node with same value is deleted in the code above.When you find all node with same value, the next node will point to next node of last node with same value.//no nodes that have value duplicatedif (cur-&amp;gt;next == next){ pre = cur;}//if there are nodes with value duplicated//need to delete current node because it has same value also.else{ delete cur; pre-&amp;gt;next = next;}cur = next;This code is the most important code to solve this problem.If there are no nodes with same value, we just set current node to previous node. The code “if (cur-&amp;gt;next == next)” means that there are no nodes with same value between current node and next node.On the other hand, As the figure above, if there are nodes with same value(1), current node must also be deleted. This is because this problem is to delete all nodes with the same value.pre-&amp;gt;next = next;Since all nodes with same value including current node are deleted, we need to set previous node again.cur = next;Finally, set next node to current node so that you can explore the next node. Complexity Analysis Time complexity: $O(N)$ The time complexity is n, which is the number of nodes in the linked list, because this solution simply traverses and deletes all nodes in the linked list. Space complexity: $O(1)$ The space complexity is $O(1)$ because it uses no additional memory. Conclusion The key point of linked list problem is creating previous node because almost linked list problems request you to disconnect and reconnect linked list. Therefore create dummy node to point to head node and use it as previous node at first. References 8 lines C++ solution.faster than 100% submissions|for beginners.explanation of approach" }, { "title": "LeeCode 662. Maximum Width of Binary Tree", "url": "/posts/LeeCode-662.-Maximum-Width-of-Binary-Tree/", "categories": "Algorithm", "tags": "Algorithm", "date": "2024-01-21 00:00:00 +0900", "snippet": " Discription Given the root of a binary tree, return the maximum width of the given tree.The maximum width of a tree is the maximum width among all levels.The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.It is guaranteed that the answer will in the range of a 32-bit signed integer.Example 1:Input: root = [1,3,2,5,3,null,9]Output: 4Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).Example 2:Input: root = [1,3,2,5,null,null,9,6,null,7]Output: 7Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).Example 3:Input: root = [1,3,2,5]Output: 2Explanation: The maximum width exists in the second level with length 2 (3,2).Constraints: The number of nodes in the tree is in the range (1 ~ 3000). k100 &amp;lt;= Node.val &amp;lt;= 100 Intuition When you encounter a problem that requires you to calculate for each level of the tree, you can usually solve it using a queue.This problem is no exception. It is a problem to find the maximum width of a tree.To find the maximum width of the tree, you need to traverse the tree using breadth-first search.In order to traverse the tree using bfs, the queue algoritm is typically used. Approach Here are the two most crucial things you need to understand to solve this problem: Traverse the tree using breadth-first search (BFS).As mentioned earlier, This problem needs to be solved using BFS. Therefore, to traverse using BFS, you need to use a queue Maintain an index for each node.The most important thing is to determine the index for each node and calculate the difference between the leftmost and rightmost nodes. Solution class Solution {public: int widthOfBinaryTree(TreeNode* root) { queue&amp;lt;pair&amp;lt;TreeNode*, long long&amp;gt;&amp;gt; que; que.push({ root, 0 }); int ret = 0; while (que.size()) { int sz = static_cast&amp;lt;int&amp;gt;(que.size()); auto first = que.front().second; int diff = 0; for (int i = 0; i &amp;lt; sz; i++) { auto p = que.front(); que.pop(); auto k = p.second - first; if (sz - 1 == i) { diff = k; } if (p.first-&amp;gt;left) { que.push({ p.first-&amp;gt;left , (2 * k) + 1 }); } if (p.first-&amp;gt;right) { que.push({ p.first-&amp;gt;right , (2 * k) + 2 }); } } ret = std::max(ret, diff + 1 /* width */); } return ret; }};In this code, you’ll initially encounter a queue.queue&amp;lt;pair&amp;lt;TreeNode*, long long&amp;gt;&amp;gt; que;The queue consists of pair representing a pointer and the index of the node. Index represents the absolute index, not the relative index of a node in a binary search tree.for example, in the figure below, the node which has value 9 is third in the level 3 of the tree but the index of node is 4. Initially, the root node is added to the queue with an index of 0. If the queue has elements, it is traversed using a while statement.int sz = static_cast&amp;lt;int&amp;gt;(que.size());Before traversing the tree, you need to store the size of the queue in a variable. This size corresponds to the number of nodes at each level of the tree.auto first = que.front().second;The “first” variable corresponds to the index of the leftmost node. Because we need to calculate width (the difference between the leftmost and rightmost nodes) of each level,we store the index of the first node in memory before traversing the level.for (int i = 0; i &amp;lt; sz; i++){ auto p = que.front(); que.pop(); auto k = p.second - first; if (sz - 1 == i) { diff = k; } ...}Traversing the levels of the tree using a loop.Pay attention to the variable “k.” Initially, “k” is always 0 as it represents the difference from the index of the first node.The variable “k” represents the number of nodes up to the p.second node.The variable “k” is used when calculating the index of next level of the tree.Variable “diff” is representing difference between most right node and most left node.You can calculate the width by adding 1 to the “diff” variable.if (p.first-&amp;gt;left){ que.push({ p.first-&amp;gt;left , (2 * k) + 1 });}if (p.first-&amp;gt;right){ que.push({ p.first-&amp;gt;right , (2 * k) + 2 });}Add the node and index of next level to queue.You can see the formula for calculating the node index at the next level.(2 * k) + 1 // left node index from parent node(2 * k) + 2 // right node index from parent nodeAs mentioned above, The variable “k” is used when calculating the index of next level.As the tree is a binary search tree, you need to multiply the variable “k” by 2.ret = std::max(ret, diff + 1 /* width */);After traversing each level, update the maximum width of the tree.Width is diff + 1. Complexity Analysis Time complexity: $O(N)$ Since we traverse all nodes of the tree, the time complexity is $O(N)$. Space complexity: $O(N)$ As we use a queue for BFS traversal, the space complexity is also $O(N)$. Conclusion Today I showed you how to traverse binary search tree with BFS.There are many ways to traverse a tree, but many problems in leetcode require you to use BFS to traverse the tree.so you must know how to traverse trees with bfs. References 662. Maximum Width of Binary TreeC++ 🔥BFS Approach with explanation 🔥 Simple solution" }, { "title": "LeeCode 873. Length of Longest Fibonacci Subsequence", "url": "/posts/LeeCode-873.-Length-of-Longest-Fibonacci-Subsequence/", "categories": "Algorithm", "tags": "Algorithm", "date": "2023-10-15 00:00:00 +0900", "snippet": " Discription A sequence x1, x2, ..., xn is Fibonacci-like if: n &amp;gt;= 3 xi + xi+1 == xi+2 for all i + 2 &amp;lt;= nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].Example 1:Input: arr = [1,2,3,4,5,6,7,8]Output: 5Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].Example 2:Input: arr = [1,3,7,11,12,14,18]Output: 3Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].Constraints: 3 &amp;lt;= arr.length &amp;lt;= 1000 1 &amp;lt;= arr[i] &amp;lt; arr[i + 1] &amp;lt;= 109 Analysis This problem is to find the length of the longest Fibonacci subsequence of arr. Fibonacci sequence has the characteristic that the sum of two adjacent terms is next term. For example, if starting with 2,3, the Fibonacci sequence is as follows.2,3,5,8,13,21... Solution //Approach 1: Brute Force with Setclass Solution {public: int lenLongestFibSubseq(vector&amp;lt;int&amp;gt;&amp;amp; arr) { std::unordered_set&amp;lt;int&amp;gt; m(arr.begin(), arr.end()); int ret = 0; for (int a = 0; a &amp;lt; arr.size(); a++) { for (int b = a + 1; b &amp;lt; arr.size() - 1; b++) { int n1 = arr[a]; int n2 = arr[b]; int f = n1 + n2; int count = 0; while (m.count(f)) { n1 = n2; n2 = f; f = n1 + n2; count++; } ret = std::max(ret, count); } } return 0 == ret ? 0 : ret + 2; }};In this code, the std::unordered_set variable was initialized taking the value from the arr. It will be used to find the sum of two adjacent terms. for (int a = 0; a &amp;lt; arr.size(); a++){ for (int b = a + 1; b &amp;lt; arr.size() - 1; b++) { int n1 = arr[a]; int n2 = arr[b]; int f = n1 + n2; int count = 0; while (m.count(f)) { n1 = n2; n2 = f; f = n1 + n2; count++; } ret = std::max(ret, count); }}This part is to find the longest length of fibonacci sub sequence. Determine two starting values by using two nested loops. The while loop statement calculates the length of Fibonacci sub sequence. while (m.count(f)){ n1 = n2; n2 = f; f = n1 + n2; count++;}This is important code. If the sum(variable f) of n1 and n2 is in the ‘m’ variable, it tries to find the next term by using the sum found before. At this point, it is important to update two values(n1, n2) previous to find next term. This process is repeated until the next value does not exist in arr.return 0 == ret ? 0 : ret + 2;If ret variable is 0, it means there is no finonacci sub sequence. Otherwise, add 2 to the ret variable because Fibonacci sub sequence consists of more than two values basically. Complexity Analysis Time Complexity $O(N^2log⁡M)$ where N is the length of A, and M is the maximum value of A.In the first for loop, It is repeated as much as the size of the arr and it is repeated as much as the size of the arr in the second loop as well. It means the time complexity of the nested loop is $O(n^2)$. $log⁡(M)$ means that the time complexity of the while loop statement. why the time complexity of the while loop statement is $log⁡(M)$? Let’s look at the figure below.https://swdevnotes.com/swift/2021/fibonacci-sequence-recursion/In the graph above, as the sequence number increases, you can observe that the Fibonacci numbers grow exponentially. The shape of the Fibonacci sequence graph resembles that of an exponential function, and this is a characteristic feature of the sequence. In fibonacci sequence, as calculating next term by summing the largest two terms, the sequence grows exponentially. Therefore, we can represent the Fibonacci sequence with the following equation. $y = a^x$ In above equation, the y represents the Fibonacci number and the x represents the sequence number. In above solution, because the time complexity of the while loop statement represents x, we can change the equation to logarithm as follows. $x = log_a(y)$It means that as finding a specific the Fibonacci number y, we need to repeat x times. As a result, the time complexity of the solution becomes $O(N^2log⁡M)$. Space Complexity The space complexity is $O(N)$. In above solution, unordered_set&amp;lt;int&amp;gt; container is used to find a Fibonacci number rapldly. Becuase the container is assigned as much as the size of arr, the space complexity is $O(N)$. Conclusion The reason I’m posting this today is because calculating the time complexity of the Fibonacci sequence was challenging. As you can see, the growth rate of the Fibonacci sequence is similar to that of an exponential function. I didn’t know why the complexity was log(M) when calculating Fibonacci sequence at first. I studied about relationship between exponential and logarithmic functions while posting this article and it helped me understand the time complexity of exponential algorithm. I hope that this article help you as well. References 873. Length of Longest Fibonacci Subsequence" }, { "title": "C++ std::tuple", "url": "/posts/tuple/", "categories": "C++", "tags": "C++", "date": "2023-10-09 00:00:00 +0900", "snippet": "When you wanna deal with multiple types, what should you do? There are likely various ways but among them, today, I am going to discuss about std::tuple. Why you use std::tuple Suppose you need to create a function to return system information.int GetSystemInfo(){ int systemNum = 1; return systemNum;}Good! However, if you have to return a system name as well, how do you return a system name?int GetSystemInfo(std::string&amp;amp; systemName){ systemName = &quot;test system&quot;; int systemNum = 1; return systemNum;}Oh! Great! However, if you need to return multiple system information, how should you return them? The first approach is to create struct or class.struct SystemInfo{ int num = 0; std::string name;}SystemInfo GetSystemInfo(std::string&amp;amp; systemName....){ SystemInfo systemInfo; systemInfo.num = 1; systemInfo.name = &quot;test&quot;; ... return systemInfo;}In code above, I created SystemInfo struct and added member variables about system information. When creating a struct or class, it is common to create a header file and a cpp file but it is inconvenient. How to use std::tuple #include &amp;lt;iostream&amp;gt;#include &amp;lt;tuple&amp;gt;#include &amp;lt;string&amp;gt;std::tuple&amp;lt;int, std::string, int&amp;gt; GetSystemInfo(){ //tuple initialization //std::tuple&amp;lt;int, std::string, int&amp;gt; systemInfo = { 1, &quot;test&quot;, 10 }; std::tuple&amp;lt;int, std::string, int&amp;gt; systemInfo; systemInfo = std::make_tuple(1, &quot;test&quot;, 10); return systemInfo;}int main(){ auto systemInfo = GetSystemInfo(); //get information from tuple. int num = std::get&amp;lt;0&amp;gt;(systemInfo); std::string name = std::get&amp;lt;1&amp;gt;(systemInfo); int id = std::get&amp;lt;2&amp;gt;(systemInfo); //ouput system information std::cout&amp;lt;&amp;lt; &quot;num: &quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl; std::cout&amp;lt;&amp;lt; &quot;name: &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl; std::cout&amp;lt;&amp;lt; &quot;id: &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; std::endl; return 0;}I have modified the GetSystemInfo() function to return system information using std::tuple. There are two methods to create std::tuple variable. The first one is initialization.//tuple initializationstd::tuple&amp;lt;int, std::string, int&amp;gt; systemInfo = { 1, &quot;test&quot;, 10 };When you initialize std::tuple, all you need to list values of tuple in initialization statement. At this point, the types listed in the tuple must match the type of value.The second one is to use std::make_tuple() function. you can assign values to std::tuple variable using std::make_tuple() function. Like when initializing, the types in tuple must match the types of values.std::tuple&amp;lt;int, std::string, int&amp;gt; systemInfo;systemInfo = std::make_tuple(1, &quot;test&quot;, 10);If you created a tuple and assigned values, Let’s use the tuple! How to get value from tuple variable is to use std::get&amp;lt;&amp;gt;() template function.auto systemInfo = GetSystemInfo();//get information from tuple.int num = std::get&amp;lt;0&amp;gt;(systemInfo);std::string name = std::get&amp;lt;1&amp;gt;(systemInfo);int id = std::get&amp;lt;2&amp;gt;(systemInfo);//ouput system informationstd::cout&amp;lt;&amp;lt; &quot;num: &quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl;std::cout&amp;lt;&amp;lt; &quot;name: &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;std::cout&amp;lt;&amp;lt; &quot;id: &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; std::endl;The first argument of get&amp;lt;&amp;gt;() is index of the type that you want to get value from tuple.Structured binding (since C++ 17)Since C++ 17, structured binding has been added. It makes std::tuple easy to use.auto systemInfo = GetSystemInfo();//Structured bindingauto [num, name, id] = systemInfo;//ouput system informationstd::cout&amp;lt;&amp;lt; &quot;num: &quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl;std::cout&amp;lt;&amp;lt; &quot;name: &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;std::cout&amp;lt;&amp;lt; &quot;id: &quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; std::endl;The structured binding statement is easy to use, all you need to list the name of variables. However, in case of using a structured binding statement, you need to assign all variables of the tuple. You cannot get only some variables from the tuple. Other Features std::tie()This function assigns the value of tuple to variables. You can use tie() when you want to reuse variables.// std::tie may work together with C++17 structured bindings: //auto position = [](int w) { return std::tuple&amp;lt;int, int&amp;gt;{ 1 * w, 2 * w }; };auto [x, y] = position(1);assert(x == 1 and y == 2);// ...std::tie(x, y) = position(2); // reuse x, y with tieassert(x == 2 and y == 4);// sub-types that are returned by a callable may differauto coordinates = [] { return std::tuple&amp;lt;char, short&amp;gt;(6, 9); };// ...std::tie(x, y) = coordinates(); // implicit conversionsassert(x == 6 and y == 9);https://en.cppreference.com/w/cpp/utility/tuple/tiestd::tuple_cat()Constructs a tuple that is a concatenation of all tuplesstd::tuple&amp;lt;int, std::string, float&amp;gt; t1(10, &quot;Test&quot;, 3.14);int n = 7;auto t2 = std::tuple_cat(t1, std::make_tuple(&quot;Foo&quot;, &quot;bar&quot;), t1, std::tie(n));n = 42;print(t2);output:(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 42)https://en.cppreference.com/w/cpp/utility/tuple/tuple_catstd::tuple::swap()Swap tuples each other.#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;tuple&amp;gt; int main(){ std::tuple&amp;lt;int, std::string, float&amp;gt; p1{42, &quot;ABCD&quot;, 2.71}, p2; p2 = std::make_tuple(10, &quot;1234&quot;, 3.14); auto print_p1_p2 = [&amp;amp;](auto rem) { std::cout &amp;lt;&amp;lt; rem &amp;lt;&amp;lt; &quot;p1 = {&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(p1) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(p1) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;2&amp;gt;(p1) &amp;lt;&amp;lt; &quot;}, &quot; &amp;lt;&amp;lt; &quot;p2 = {&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(p2) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(p2) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;2&amp;gt;(p2) &amp;lt;&amp;lt; &quot;}\\n&quot;; }; print_p1_p2(&quot;Before p1.swap(p2): &quot;); p1.swap(p2); print_p1_p2(&quot;After p1.swap(p2): &quot;); swap(p1, p2); print_p1_p2(&quot;After swap(p1, p2): &quot;);}output:Before p1.swap(p2): p1 = {42, ABCD, 2.71}, p2 = {10, 1234, 3.14}After p1.swap(p2): p1 = {10, 1234, 3.14}, p2 = {42, ABCD, 2.71}After swap(p1, p2): p1 = {42, ABCD, 2.71}, p2 = {10, 1234, 3.14}https://en.cppreference.com/w/cpp/utility/tuple/swap Conclusion Today, we discussed about std::tuple. I think the tuple is very useful feature in C++. I recommend using tuple with ‘auto’ keyword. It makes code easy to use and concise. References C++ 17 의 std::optional, variant, tuple 살펴보기 C++ tuple 사용법 &amp;amp; 예제 std::tuple " }, { "title": "Blocking and Non-Blocking Socket", "url": "/posts/Blocking-and-Non-Blocking-Socket/", "categories": "C++, Network", "tags": "C++, Network", "date": "2023-10-08 00:00:00 +0900", "snippet": "I was recently studying Overlapped I/O and I came across the concepts of blocking and non-blocking socket. I have already known the concepts of blocking socket but I didn’t know for non-blocking socket. So, today I gonna talk about difference between blocking and non-blocking socket.What is Blocking and Non-Blocking?We usually call the function to process our specific request. At that time, the function processes the request and returns the answer that we want to. What happens if the function takes a long time to process? You will have to wait for the function to return and feel like the flow has stopped. In this way, when the processing time of a function is long and it feels like the flow has stopped, it is called blocking. Otherwise, If you don’t need to wait for function to return, It is called non-blocking.Why a Socket is Blocked?http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.htmlWhen you call the recvfrom function, control is transferred to the system. if there is no data to read, the recvfrom function don’t return and you need to wait for the function to return. At this time, the thread of application becomes Waiting. When the system receives the data from remote computer, the system copies received data from receive buffer to the memory of application (from kernel space to user space) the control is transferred from the system to application and thread becomes Running. The Problem of Blocking I/O Medel The socket handle that is made when you create socket is blocking mode basically.SOCKET socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);The server sends the packet received back to the client and outputs the size of packet received every second. But there is a problem in this code.while (1) {if (clientSocket != INVALID_SOCKET){ char messageBuffer[MAX_BUFFER]; int receiveBytes = recv(clientSocket, messageBuffer, MAX_BUFFER, 0); if (receiveBytes &amp;gt; 0) { printf(&quot;TRACE - Receive message : %s (%d bytes)\\n&quot;, messageBuffer, receiveBytes); int sendBytes = 0; do { sendBytes = send(clientSocket, messageBuffer, static_cast&amp;lt;int&amp;gt;(strlen(messageBuffer)), 0); if (sendBytes &amp;gt; 0) { printf(&quot;TRACE - Send message : %s (%d bytes)\\n&quot;, messageBuffer, sendBytes); } if (SOCKET_ERROR == sendBytes) { int error = WSAGetLastError(); if (error == WSAEWOULDBLOCK) { printf(&quot;TRACE - Recv error WSAEWOULDBLOCK(%d)\\n&quot;, error); Sleep(1); //wait for 1 Milliseconds. } else { break; } } } while (0 &amp;lt; sendBytes); receiveBytesPerSec += receiveBytes; } if (timeGetTime() - startTime &amp;gt;= 1000) { printf(&quot;TRACE - receiveBytes: %d bytes)\\n&quot;, receiveBytesPerSec); startTime = timeGetTime(); receiveBytesPerSec = 0; }}}If the client does not send the packet, The server waits for it, which means that the server is blocked in the recv() function. The recv() does not return until the packet is received because the socket is in blocking mode. So the server can’t output the size of packet received every second. Non-Blocking Socket Making non-blocking mode socket is easy. You can change a socket from blocking mode to non-blocking mode using the ioctlsocket() function.//https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-ioctlsocket//-------------------------// Set the socket I/O mode: In this case FIONBIO// enables or disables the blocking mode for the // socket based on the numerical value of iMode.// If arg = 0, blocking is enabled; // If arg != 0, non-blocking mode is enabled.u_long arg = 1;ioctlsocket(clientSocket, FIONBIO, &amp;amp;arg);The code above means to change the blocking mode of client socket to non-blocking mode. Now If there are no packets in the socket’s receive buffer, recv() will returns SOCKET_ERROR(-1). The WSAGetLastError() function returns WSAEWOULDBLOCK.while (1) {if (clientSocket != INVALID_SOCKET){ char messageBuffer[MAX_BUFFER]; int receiveBytes = recv(clientSocket, messageBuffer, MAX_BUFFER, 0); if (receiveBytes &amp;gt; 0) { //sending packet receiveBytesPerSec += receiveBytes; } if (SOCKET_ERROR == receiveBytes) { int error = WSAGetLastError(); if (error == WSAEWOULDBLOCK) { printf(&quot;TRACE - Recv error WSAEWOULDBLOCK(%d)\\n&quot;, error); } } if (timeGetTime() - startTime &amp;gt;= 1000) { printf(&quot;TRACE - receiveBytes: %d bytes)\\n&quot;, receiveBytesPerSec); startTime = timeGetTime(); receiveBytesPerSec = 0; }}}Because the socket is in non- blocking mode, it can output the size of packets received normally. But there is still a problem. The recv() function always returns, whether there are packets in the receive buffer or not, so you need to periodically call the recv() function. In the code above, the recv() function is continuously being called within a while loop, which can result in a highly busy state for the thread. If you reduce the frequency of recv() function calls, the response sent to the client will slow down, whereas increasing the call frequency will result in the thread being in a highly busy state. This problem can be resolved with iocp. Non-Blocking Socket(Sending packet) When does the send() function become blocking? To understand this, you need to know first how the send() function is processed internally when sending data with block mode socket.https://www.researchgate.net/figure/An-established-TCP-connection_fig1_220926307A kernel socket has two buffers: the first one is a send buffer to send packet and the second one is a receive buffer to receive packet. When the send() is called, the data you want to send is copied from user space to kernel space then it is appended to the end of send buffer to send data in order.In most cases, when you call the send() function, it returns promptly. However, if there is network latency or the remote host fails to process packets, the packets in the send buffer may not be sent and the send buffer to become full. In such cases, the send() function enters a blocking state until space becomes available in the buffer.//sending packetint sendBytes = 0;do{ sendBytes = send(clientSocket, messageBuffer, static_cast&amp;lt;int&amp;gt;(strlen(messageBuffer)), 0); if (sendBytes &amp;gt; 0) { printf(&quot;TRACE - Send message : %s (%d bytes)\\n&quot;, messageBuffer, sendBytes); } if (SOCKET_ERROR == sendBytes) { int error = WSAGetLastError(); if (error == WSAEWOULDBLOCK) { printf(&quot;TRACE - Recv error WSAEWOULDBLOCK(%d)\\n&quot;, error); Sleep(1); //wait for 1 Milliseconds. } else { break; } }} while (0 &amp;lt; sendBytes);In the code above, the clientSocket is set to non-blocking mode. As a result, the send() function returns promptly, whether the send buffer is full or not. Typically, the send buffer returns the size of the packet to be sent, but if the send buffer is full, it will return SOCKET_ERROR(-1), and the WSAGetLastError() function will return WSAEWOULDBLOCK. In this code, when the send buffer is full, it waits for 1 second and then attempts to send again. When using a non-blocking mode socket like this, the logic to detect sending or receiving data failure and try it again. Conclusion Today, I talked about the concept of blocking and non-blocking socket. Infact, this post is intended to understand overlapped I/O which will be posted in the near future. I hope this article will help you. References 블록킹,논블록킹,동기 I/O,비동기 I/O(Overlapped I/O)" }, { "title": "LeetCode 799. Champagne Tower", "url": "/posts/LeetCode-799.-Champagne-Tower/", "categories": "C++, Algorithm", "tags": "C++, Algorithm", "date": "2023-10-02 00:00:00 +0900", "snippet": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne.Then, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.)For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)Example 1:Input: poured = 1, query_row = 1, query_glass = 1Output: 0.00000Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.Example 2:Input: poured = 2, query_row = 1, query_glass = 1Output: 0.50000Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.Example 3:Input: poured = 100000009, query_row = 33, query_glass = 17Output: 1.00000AnalysisThis problem is to find out the amount of champagne left in a specific glass which is placed at query_row, query_glass. My first approach is to subtract the amount of champagne equal to the number of glasses and then dividing the remaining champagne into the remaining glasses.SimulationSuppose there are six glasses on table and champagne that can be poured the amount of four glasses.When you pour champagne into the top glass, one glass is filled and there are three glasses champagne left. The amount of champagne that can be poured from first row to second row is 1.5 in each glass.The second row glasses is filled and remaining champagne is poured to glasses in next row. The middle of glass at third row should be multiplied 2 because it can get champagne from two glasses at second row. Let’s create the above simulation as code. Solution class Solution {public: double champagneTower(int poured, int query_row, int query_glass) { std::vector&amp;lt;double&amp;gt; cur(1, poured); for (int i = 0; i &amp;lt;= query_row; i++) { std::vector&amp;lt;double&amp;gt; next(i + 2, 0); for (int a = 0; a &amp;lt;= i; a++) { if (1 &amp;lt;= cur[a]) { next[a] += (cur[a] - 1) / 2.0; next[a + 1] += (cur[a] - 1) / 2.0; cur[a] = 1; } } if (i != query_row) { cur = next; } } return cur[query_glass]; }};cur is vector. It represents the amount of champagne at current row.for (int i = 0; i &amp;lt;= query_row; i++){ std::vector&amp;lt;double&amp;gt; next(i + 2, 0); ...The index of first row is 0. The amount of champagne left should be filled when a glass of first is filled as well. So you need to create next variable as vector.Here is the most important code in this problem.for (int a = 0; a &amp;lt;= i; a++){ if (1 &amp;lt;= cur[a]) { next[a] += (cur[a] - 1) / 2.0; next[a + 1] += (cur[a] - 1) / 2.0; cur[a] = 1; }}This code represents to divide the amount champagne in each glass of current row into two glasses in next row. And then a current glass is filled with 1.if (i != query_row){ cur = next;}We need to change cur to next to fill the glasses in the next row. but you don’t need to change at last row because you need remaining champagne information in last row.return cur[query_glass];If you fill champagne to all glasses, all you need to return the amount of champagne at query_glass position of the cur. Complexity Analysis Time Complexity: O(R^2), where R is the number of rows. As this is fixed, we can consider this complexity to be O(1). Space Complexity: O(R^2), or O(1) by the reasoning above. Conclusion When I looked at the solution, I could understand it easily and solved it easily. But When I first encountered this problem, I didn’t know how to approach. I realized I needed to practice more. References 799. Champagne Tower" }, { "title": "LeetCode 652. Find Duplicate Subtrees", "url": "/posts/LeetCode-652.-Find-Duplicate-Subtrees/", "categories": "C++, Algorithm", "tags": "C++, Algorithm", "date": "2023-09-30 00:00:00 +0900", "snippet": "Given the root of a binary tree, return all duplicate subtrees.For each kind of duplicate subtrees, you only need to return the root node of any one of them.Two trees are duplicate if they have the same structure with the same node values.Example 1:Input: root = [1,2,3,4,null,2,4,null,null,4]Output: [[2,4],[4]]AnalysisThis problem is to find subtrees which have same structure. First you need to perform post order traversal in order to get the structure of subtrees. Because post order traversal traverses left and right subtrees first, we can know overall structure of the tree in last root node. If you get to know the structure of subtrees, you need to record it to find same subtrees. when you record it, first you serialize it as string then store it to extra memory. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution { string postOrderTraversal(TreeNode* root, unordered_map&amp;lt;string, vector&amp;lt;TreeNode*&amp;gt;&amp;gt;&amp;amp; memo) { if (nullptr == root) { return &quot;&quot;; } string l = postOrderTraversal(root-&amp;gt;left, memo); string r = postOrderTraversal(root-&amp;gt;right, memo); string result = &quot;(&quot; + l + to_string(root-&amp;gt;val) + r + &quot;)&quot;; memo[result].push_back(root); return result; }public: vector&amp;lt;TreeNode*&amp;gt; findDuplicateSubtrees(TreeNode* root) { vector&amp;lt;TreeNode*&amp;gt; ret; unordered_map&amp;lt;string, vector&amp;lt;TreeNode*&amp;gt;&amp;gt; memo; postOrderTraversal(root, memo); for (const auto&amp;amp; [_, list] : memo) { if (list.size() &amp;gt;= 2) { ret.push_back(list[0]); } } return ret; }};Because the postOrderTrversal function is a function that performs postorder traversal, it traverses from the left subtree to the right subtree first, and then checks the root node. The key code is the part that serializes and records subtrees. Let’s see the code below.string l = postOrderTraversal(root-&amp;gt;left, memo);string r = postOrderTraversal(root-&amp;gt;right, memo);string result = &quot;(&quot; + l + to_string(root-&amp;gt;val) + r + &quot;)&quot;;memo[result].push_back(root);The variable “l” represents the left subtree serialized as a string. The variable “r” represents the right subtree serialized as a string. Serialize current tree by combining left, right subtree string and current value. And store the result string to memo variable. If there are subtrees with the same structure, it will be pushed to the vector in the memo and the vector size will be 2 or more.for (const auto&amp;amp; [_, list] : memo){ if (list.size() &amp;gt;= 2) { ret.push_back(list[0]); }}When the tree traversal ends, all you need to do is find vectors that the size 2 or greater. Conclusion When I first solved this problem, I didn’t know how to save subtree. The method that stores the structure of subtree by serializing as a string was quite creative. References Clean Code with Explanation" }, { "title": "Find Duplicated Elements Between Two Arrays in C++", "url": "/posts/Find-Duplicated-Elements-Between-Two-Arrays-in-C++/", "categories": "C++, Algorithm", "tags": "C++, Algorithm", "date": "2023-09-24 00:00:00 +0900", "snippet": "Someday I was wondering how to get elements which is duplicated between two arrays. So, Today I am gonna talk to you about this. Let’s see code belowApproach 1: Brute Force//Approach 1: Brute Force#include &amp;lt;iostream&amp;gt;#include &amp;lt;array&amp;gt;#include &amp;lt;vector&amp;gt;int main(){ std::array&amp;lt;int, 5&amp;gt; arr1 = {10, 20, 30, 40, 50}; std::array&amp;lt;int, 5&amp;gt; arr2 = {100, 200, 30, 400, 50}; for (auto e1 : arr1) { for (auto e2 : arr2) { if (e1 == e2) { std::cout &amp;lt;&amp;lt; e1 &amp;lt;&amp;lt; &quot; &quot;; } } } return 0;}Elentment 30, 50 are duplicated in the code above. So you can see that 30 and 50 are output.The first approach is brute force. the elements of two arrays is compared using nested loop. this solution is simple and easy to complement but inefficient because the loop is repeated until n *m times (n is arr1 size and m is arr2 size). so time complexity is O(n^2). O(n^2) is very inefficient time complexity. I will optimize above code. second approach is using unordered_set containerApproach 2: To Use Extra Space//Approach 2: To Use Extra Space#include &amp;lt;iostream&amp;gt;#include &amp;lt;array&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;unordered_set&amp;gt;int main(){ std::array&amp;lt;int, 5&amp;gt; arr1 = { 10, 20, 30, 40, 50 }; std::array&amp;lt;int, 5&amp;gt; arr2 = { 100, 200, 30, 400, 50 }; std::unordered_set&amp;lt;int&amp;gt; set; for (int i = 0; i &amp;lt; arr1.size(); ++i) { set.insert(arr1[i]); } for (int i = 0; i &amp;lt; arr2.size(); ++i) { if (set.count(arr2[i])) { std::cout &amp;lt;&amp;lt; arr2[i] &amp;lt;&amp;lt; &quot; &quot;; } } return 0;}The second approach is to use the std::unordered_set container. This container is used to check for duplicate elements. First, we add all the elements of arr1 to the container. Then, we traverse the array arr2 to find elements that are duplicates of elements in arr1.Second approach time complexity is O(n + m) and space complexity is O(n) Time complexity of adding all elements of arr1 to container is O(n) (n represents size of arr1) Time complexity of finding element duplicated to elements of arr2 is O(m) (m represents size of arr2)Second approach time complexity is more efficient than first approach.We get to know that we could find elements duplicated efficiently when we use additional memory. But it is not appropriate in the environment can not use additional memory. Is there more efficient way to find elements without additional memory?Approach 3: Sort ArrayYes it is. If we sort given arrays, we can solve this problem without additional space.//Approach 3: Sort Array#include &amp;lt;iostream&amp;gt;#include &amp;lt;array&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;unordered_set&amp;gt;#include &amp;lt;algorithm&amp;gt;int main(){ std::array&amp;lt;int, 5&amp;gt; arr1 = { 10, 20, 30, 40, 50 }; std::array&amp;lt;int, 5&amp;gt; arr2 = { 100, 200, 30, 400, 50 }; std::sort(arr1.begin(), arr1.end()); std::sort(arr2.begin(), arr2.end()); int i = 0, j = 0; std::vector&amp;lt;int&amp;gt; duplicated; while (i &amp;lt; arr1.size() &amp;amp;&amp;amp; j &amp;lt; arr2.size()) { if (arr1[i] == arr2[j]) { std::cout &amp;lt;&amp;lt; arr1[i] &amp;lt;&amp;lt; &quot; &quot;; i++; j++; } else if (arr1[i] &amp;lt; arr2[j]) { i++; } else { j++; } } return 0;}First, sort given two arrays. then compare elements starting from smallest element. If two elements are different, Increase the index of smaller.Third approach time complexity is O(n log n + m log m) and There is no space complexity. The time complexity of std::sort() function is O(n log n). We used sort function 2 times to arr1 and arr2.This solution do not use extra space but it is not appropriate in case that the array to need to sort. Conclusion The Second approach affects memory usage because it uses additional memory to create unordered_set. On the other hand, The Third approach uses less memory because it uses sorting, but the two arrays need to be sorted, which can lead to greater time complexity if the array is larger.Therefore, which method is more efficient depends on the situation and must be chosen considering the size of the input data and memory limitations." }, { "title": "Be careful Try Not to Use Invalidated Iterator", "url": "/posts/Be-careful-Try-Not-to-Use-Invalidated-Iterator/", "categories": "C++", "tags": "C++, STL", "date": "2023-09-10 00:00:00 +0900", "snippet": "Recently, there was a case of a bug while running a program using invalidated iterator in the team I work for.Today, we will find out what the iterator invalidation is and summarize the cases of iterator invalidation.What is Iterator Invalidation?The Iterator Invalidation is that container to which iterator point internally change due to an add/delete operation. i.e. when elements are moved from one position to another, and the initial iterator still points to the old invalid location, then it is called Iterator invalidation.In case of Change Container Size while Traversing the Container. (Reallocation of Container Memory)vector&amp;lt;int&amp;gt; v = { 1, 5, 10, 15, 20 };for (auto it = v.begin(); it != v.end(); it++) { cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt;&quot;, &quot;; if ((*it) == 5) { v.push_back(100); } }Will the code above work well? if you look at the code simply, it seems to be no problem.however the iterator is invalidated in above code while traversing the container. Above code causes indeterminate behavior due to invalidating iterator while traversing the container.When an element is 5, 100 is added to the vector. At this time, memory reallocation occurs while exceeding the vector’s maximum capacity. Allocate memory to a location that is completely different from the original location and move all existing elements to a new space. but the iterator still point to old memory location.As a result, the iterator performs numerous iterations to reach at the v.end(). If you add or delete elements while traversing the container, you may use an invalidated iterator, you must be careful this.As we saw in the above case. If you add elements to a vector when there is no free space, the memory of vector is reallocated and iterator is invalidated. What if the vector has enough capacity?If you add elements in a vector when there is free space, memory reallocation and iterator invalidation do not occur.vector&amp;lt;int&amp;gt; v;v.reserve(10);v.push_back(1);v.push_back(5);v.push_back(10);v.push_back(15);v.push_back(20);cout &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; endl; // size is 5 cout &amp;lt;&amp;lt; v.capacity() &amp;lt;&amp;lt; endl; // capacity is 10 for (auto it = v.begin(); it != v.end(); it++){ cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &quot;, &quot;; if ((*it) == 5) { v.push_back(100); }}In Case of Add Element at The Middle of Vector When Vector Has Enough Space.What if add element at the middle of the vector when the vector has enough space?std::vector&amp;lt;int&amp;gt; vec;vec.reserve(10);vec.push_back(10);vec.push_back(20);vec.push_back(30);auto it = vec.begin();for (; it != vec.end(); ++it){ std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &quot;, &quot;; if (*it == 20) { vec.insert(it, 100); }}The above code is the code that adds 100 to vec when the value pointed to by the iterator is 20. Does this code work well? The above code is repeated infinitely. When an element is added to the vector, the elements on the right side of added position are moved to the right once. As a result, the iterator encounters an element that meets the same condition again in the next loop, and another element is added. when an element is added until there is no space left in the vector and the vector reallocates memory,An invalidated (pointing to an old memory) iterator repeats the for statement infinitely until it meets the end of the reassigned vector.In Case of Deleting an Element of The Vector.std::vector&amp;lt;int&amp;gt; vec = { 10,20,30,40,50 };auto it = vec.begin() + 2;vec.erase(it);std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;In the code above, the iterator points to the third element(30) of the vector. What happens when you delete an element that the iterator points to? This is because after the element 30 pointed by the iterator was deleted, the other elements after the deleted element were moved once to the left (the movement of the element occurred). It can be said that this iterator has been invalidated because the element pointed to by the iterator has changed after the element was deleted from the vector.Let’s check why the above code is invalidated with the example below.std::vector&amp;lt;int&amp;gt; vec = { 10,20,30,40,50 };auto it = vec.begin();for (; it != vec.end(); ++it) { std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl; if (*it == 20) { vec.erase(it); } }What will be the output of the above code? In the code above, while touring the container, elements that meet certain conditions were deleted. Is the output 10,20,30,40,50? no, it is 10,20,40,50.As 20 was deleted, the elements after 20 moved once to the left.When the vec.erase(it) is performed, the element to which iterator point change 20 to 30. This iterator is invalidated because the element that the iterator points to has changed.After that, The iterator points to 40 because the iterator is increased in the increment expression of the loop. Conclusion Today, We learned about in case that iterator of vetor is invalidated and problem that occurs when using the iterator which is invalidated.The point we need to be careful is that the iterator which points to element may be invalidated after insert or erase operation in the loop." }, { "title": "What is Time Complextiy", "url": "/posts/What-is-Time-Complexity/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-02-20 00:00:00 +0900", "snippet": "AbstractThese days, I am solving the LeetCode problems one by one a day.If I solve the problem, it will tell me the CPU usage rate and memory usage rate of my algorithm. One day, I wondered if my algorithm is efficient.One of the ways to evaluate the efficiency of an algorithm is to calculate the time complexity.In this post, we will learn about time complexity.What is Time ComplexityTime complexity means the time an algorithm takes to solve a problem.It can be said that the shorter the time to solve the problem, the more efficient the algorithm is. So, How can we calculate time complexity?Should we calculate the total time it takes for the algorithm to solve the problem? That could be a way too. However, the method of calculating the total execution time of an algorithm may have different results depending on the execution environment in which the algorithm is run. Therefore, we must use a method that will produce the same results in any environment.Asymtotic NotationWhen analyzing the performance of an algorithm to solve a problem, it is difficult to obtain a constant result due to various factors such as the type of data given, the environment in which the experiment is performed, and the performance of the system used for the experiment, and the comparison result may not always be constant. An effective solution of this is asymptotic analysis. It is a method of counting the number of executions of an operation Instead of measuring the execution time. There are three expression methods for asymptotic analysis. Omega Notation, $Ω$ The notation $Ω(n)$ is the formal way to express the lower bound of an algorithm’s running time. It measures the best case time complexity or the best amount of time an algorithm can possibly take to complete. Big Oh Notation, $Ο$ The notation $Ο(n)$ is the formal way to express the upper bound of an algorithm’s running time. It measures the worst case time complexity or the longest amount of time an algorithm can possibly take to complete. Theta Notation, $θ$ The notation $θ(n)$ is the formal way to express both the lower bound and the upper bound of an algorithm’s running time. It is represented as follows −When expressing time complexity, Big O is mainly used. Why is that?Algorithm execution time may depend on the given data.Insertion Sort Algorithm The Worst Case : If it is sorted in reverse order. The Best Case : If the data is sorted and sorting is not required any more. The algorithm performance is always better than worst case, whatever the data is given. In order to always express constant performance regardless of data conditions,It is most common to judge by the number of executions for the worst case.Time complexity is calculated by the total number of basic operations performed to determine the exact efficiency of the algorithm. Basic operations mean data input/output(=), arithmetic(+,-,/ ,*), comparison(&amp;lt;,&amp;gt;, &amp;lt;=, &amp;gt;=, ==) and $control statement(if, switch).Time complexity can be expressed as the sum of operations. If the number of operations is expressed as a polynomial, the time complexity is expressed only with the unknown of the highest order term and exponential of the highest order term.The Reason Why Only The Unknown and Exponential of The highest Order Term Are LeavedAsymptotic notaion considers only the highest order terms excluding the insignificant terms to focus on the significant rate growth at runtime.Rate growth: the rate growth of function depending on input data size. Assuming there is a function as follow :[ x^2 + 10x + 20]As x exceeds 12, the value of the 10x+20 expression is no longer meaningful.This is the reason why the highest order term, which has the greatest influence on the amount of the increase of a function depending on input value x, is used for the time complexity.Calculate Time Complexity of Insertion Sort.void insertionSort(std::vector&amp;lt;int&amp;gt;&amp;amp; list){ int n = list.size(); //outer loop count is n-1 including i++ of last loop for (int i = 1; i &amp;lt; n; i++) { int curNum = list[i]; // (1) n - 1 int a = i - 1; for (; 0 &amp;lt;= a; a--) { if (list[a] &amp;gt; curNum) // (2) Up to i times { list[a + 1] = list[a]; // (3) Up to i times } else { //If list is already sorted, call break break; } } list[a + 1] = curNum; // (4) n - 1 }}The sum up to i (2)(3) can be expressed as the sum of arithmetic sequences.[ \\sum_{i=1}^{n-1}{i} = \\frac{(n-1)(1+n-1)}{2} = \\frac{n(n-1)}{2}]So, When the data is sorted in reverse order(the worst case), the time complexity of insertion sort is as follows.[ 2\\times(n-1) + 2\\times \\frac{n(n-1)}{2} = n^2 + n - 2 = O(n^2)]When all data is already sorted(the best case), In each loop, only list[a] &amp;gt; curNum (2) is checked and the loop is exited. This means that list[a] &amp;gt; curNumber is executed n - 1 times.So, The time complexity in the best case is as follows.[ 3\\times(n-1) = 3n -3 = O(n)]The Type of Big O Time ComplexityConstant time $O(1)$ : If the algorithm performs constant operation regardless of the input data,the time complexity is Constant time.void print(){ std::cout&amp;lt;&amp;lt;&quot;Hello World!&quot;&amp;lt;&amp;lt;std::endl;}Logarithmic time $O(LogN)$ : As the input data increases, If the number of operations increases in proportion to $LogN$ , the time complexity is Logarithmic time.bool BinarySearch(const std::vector&amp;lt;int&amp;gt;&amp;amp; v, int start, int end, int key) { if (start &amp;gt; end) return false; int mid = (start + end) / 2; if (v[mid] == key) { return true; } else if (v[mid] &amp;gt; key) { return BinarySearch(v, start, mid - 1, key); } else { return BinarySearch(v, mid + 1, end, key); }}Linear time $O(N)$ : As input data increases, if the number of operations increase in proportion to input data size, the time complexity is Linear time.bool find(std::vector&amp;lt;int&amp;gt; v, int n){ for(const auto e : v) { if(n == e) { return true; } } return false;}Quadratic time $O(N^2)$ : As input data increases, if the number of operations increase in proportion to square of the number of input data, the time complexity is Quadratic time.void SelectionSort(std::vector&amp;lt;int&amp;gt;&amp;amp; v){ for (int a = 0; a &amp;lt; v.size(); a++) { for (int b = a + 1; b &amp;lt; v.size(); b++) { if (v[a] &amp;gt; v[b]) { int temp = v[a]; v[a] = v[b]; v[b] = temp; } } }}Exponential time $O(2^N)$ : As input data increases, if the number of operations increase in proportion to $2^N$ of the number of input data, the time complexity is Exponential time.int Fibonacci(int num){ if(num == 0) { return 0; } else if(num == 1) { return 1; } else { return Fibonacci(num - 1) + Fibonacci(num - 2); }}The following shows the amount of change in the function according to the type of time Big O time complexity.ConclusionToday, We learned about the time complexity.When designing and implementing algorithms, I think there is a difference between knowing how to calculate the time complexity and not knowing it.Developers should always consider whether the time complexity of the algorithm they wrote is bestReferencesTime Complexity, Space ComplexityAsymtotic notationLogarithmic Time Complexity" }, { "title": "The Way to Erase Items in STL Containers Is All Different", "url": "/posts/The-Way-to-Erase-Items-in-STL-Containers-Is-All-Different/", "categories": "C++", "tags": "C++, STL", "date": "2022-01-29 00:00:00 +0900", "snippet": "IntroductionBecuase the way to erase items in STL containers is all different, Often, it can cause mistakes. Today, Let’s find out how to erase elements for each container and situation.Before we start, It is necessary to divide containers into main three categories. contiguous memory container std::list associative container vector, string, deque std::list map, set, multimap.. Each container has a different way to erase the elements.1. When you use contiguous memory container, Use erase-remove idiom.Suppose we have a container c with an int type element.std::vector&amp;lt;int&amp;gt; c = {1,2,3,111,4,5,111,6};If you want to erase value which is 111, You can use the erase-remove idiom like this:#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;int main(){ std::vector&amp;lt;int&amp;gt; c = { 1, 2, 3, 111, 4, 5, 111, 6 }; c.erase(remove(c.begin(), c.end(), 111), c.end()); for_each(c.begin(), c.end(), [](int e) { std::cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; &quot; &quot;; }); std::cout &amp;lt;&amp;lt; std::endl; return 0;}Because string is vector which has char type, The same goes for string.std::string c = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;c&#39;,&#39;g&#39; };c.erase(remove(c.begin(), c.end(), &#39;c&#39;), c.end());2. When you use std::list, Use remove member function.In fact, you can use the erase-remove idiom on std::list as well.However, std::list has a more efficient way.std::list&amp;lt;int&amp;gt; c = { 1, 2, 3, 111, 4, 5, 111, 6 };c.remove(111);3. When you use assosiative container, Use erase member function.std::multiset&amp;lt;int&amp;gt; c = { 1, 2, 3, 111, 4, 5, 111, 6 };c.erase(111);The associative containers don’t have any function named remove. However, you can use erase member function instead. If you use remove algorithm to erase element, it will corrupt the container.Erase of associative container is more efficient than remove of the sequence container.Erase take logarithmic time and remove task linear time.4. You must be careful, When you erase element satisfying predicate in associative container.Erasing elements satisfying specific predicate in sequence container(vector, string, list) is simple. All you need to do is replace remove with remove_if.bool isOdd(int num){ return num % 2 != 0;}int main(){ std::vector&amp;lt;int&amp;gt; c = { 1,2,3,111,4,5,111,6 }; c.erase(remove_if(c.begin(), c.end(), isOdd), c.end()); return 0;}But it is not simple on associative container.There are two ways you can use. One is easy to code but it not efficient.another is efficient.After adding elements that do not satisfy the condition to the new container, the original container is exchanged for a new container.std::multiset&amp;lt;int&amp;gt; oc = { 1, 2, 3, 111, 4, 5, 111, 6 };std::multiset&amp;lt;int&amp;gt; nc;remove_copy_if(oc.begin(), oc.end(), inserter(nc, nc.end()), isOdd);oc.swap(nc);The drawback to this approach is that it involves copying all the elements that aren’t being removed.You can avoid this cost by removing the elements from original container directly.However, Because associative container don’t support remove function like remove_if(), You need to write loop to iterate over the elements of the container.The code is simple like this:std::multiset&amp;lt;int&amp;gt; oc = { 1, 2, 3, 111, 4, 5, 111, 6 };for (auto i = oc.begin(); i != oc.end(); ++i){ if (isOdd(*i)) { oc.erase(i); }}Will the above code work well? No, the ‘i’ was invalidated after the erase function was returned.Therefore, when the invalidated ‘i’ increased (++i) in iteration-expression of loop, a runtime error occurs.To avoid this problem, you make ‘i’ point to next element before calling erase function.The easiest way to do that is to use postfix increment on i.for (auto i = oc.begin(); i != oc.end();){ if (isOdd(*i)) { oc.erase(i++); } else { ++i; }}At this time, the increment statement of the loop must be deleted. Memory contiguous containers also have the above problem.Suppose we erase element satisfying specific condition while looping the container.std::vector&amp;lt;int&amp;gt; oc = { 1, 2, 3, 111, 4, 5, 111, 6 };for (auto i = oc.begin(); i != oc.end(); ++i){ if (isOdd(*i)) { oc.erase(i); }}This is the code to pass an iterator to the erase function if the elements of the vector are odd.Will the above code work well? No, The above code ocurrs a runtime error.In memory contiguouse container, Invoking erase not only invalidates all iterators pointing to the erased element, it also invalidates all iterators beyond the erased element. It doesn’t matter if we write i++, ++i.To solve this problem in memory contiguous container, you need to use return value of erase.for (auto i = oc.begin(); i != oc.end();){ if (isOdd(*i)) { i = oc.erase(i); } else { ++i; }}If the element satisfies the condition, passes the iterator to erase function and overwrites it with return value of erase function. Otherwise just increases the iterator.ConclusionTo summarize If you want to erase specific value in a container : If the container is memory contiguous container, Use erase-remove idiom. If the container is list, Use remove member function. If the container is associative container, Use erase member function. If you want to erase all elements satisfying specific predicate : If the container is memory contiguous container, Use erase-remove_if idiom. If the container is list, Use remove_if member function. If the container is associative container, Use the way to swap after using remove_copy_if() or write loop to iterate over the container. Referred to Effective STL" }, { "title": "What is difference between Range-based loop and std::for_each()", "url": "/posts/What-is-difference-between-Range-based-loop-and-std-for_each()/", "categories": "C++", "tags": "C++, STL", "date": "2022-01-22 00:00:00 +0900", "snippet": "IntroductionWhen the C++ has introduced at first, many features were added. remarkable one thing among the features was two kind of for loop.One thing is Range-based for loop, another is for_each() functions.They are new techniques for iterating through the elements of a sequence container like vector, array, and string.Nowadays, many programmers have used above two features to iterate containers. Today, I’m going to talk about the proper use of the two loop statement above.1. Range-based For Loop is familiar.Existing for and while loops need to define variables to repeat logic like i, j, k.int main(){ for(int i = 0; i &amp;lt; 10; i++) { //someting... } return 0;}But Range-based for loop to iterate sequence container don’t need to define any variables.You just define variable to access to element of container.int main() { std::vector&amp;lt;int&amp;gt; v{ 1,2,3,4,5 }; for (const int&amp;amp; item : v) { cout &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &quot; &quot;; } return 0;}This can iterates container and access to all elements in container sequentially.Also, when you want to exit or continue inside loop, you can use continue, break statements like a normal loop statements(for, while).How to use Range-based for loop is not strange compare to normal loop. so more convenient to write.2. std::for_each() can generalize.std::for_each() is template function which take two parameters(begin() and end()) and one funtion object which will use elements of the sequence container.The prototype of the function looks liketemplate &amp;lt;class InputItr, class Functor&amp;gt;Functor for_each(InputItr begin, InputItr end, Functor fnobj);Where InputIter is a type which meets the requirement of an InputIterator concept and Functor is a type of callable object like std::function, lamda expression or a functor. Functor should be moveconstructible and match the signature of the following functions:void fun(const Type &amp;amp;a); orvoid fun(Type a); Where the type Type should be such that an object of InputItr can be dereferenced and implicitly converted to Type.Let’s look at the follow example code:#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;int main(){ std::vector&amp;lt;int&amp;gt; vec = {1,2,3,4,5}; int sum = 0; std::for_each(vec.begin(), vec.end(), [&amp;amp;sum](int e) { sum += e; } ); std::cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; std::endl; return 0;}This code is simple example code calculating sum of all elements in container with std::for_each().As you can see, std::for_each() tasks two iterators and one function object(here lamda).You already take a hint, std::for_each can generalize to any situation.If you want to sum some set of containers, All you need to change start and last. If you want to multiply all elements in container, All you need to change lamda logic. You can reuse source code as much as you want.Use It Appropriately Depending on Where You Use It.If you want to access all elements of your container simply, It is better to use Range-based for loop than std::for_each().Also Because Range-based for loop has similiar usage to normal for loop, Source code is more clearer than when you use std::for_each().But It can’t generalize. If you want to access some set of container? It can’t be.If you want to access of container in reverse order? It can’t be.ConclusionThey all work like a normal loop internally, hence performance is same.It doesn’t matter which for loop you use. Important thing is to use It appropriately depending on where you use ut.Referred to C++ 11: Range based for loop and std::for_each() function,Why You Should Use std::for_each over Range-based For Loops" }, { "title": "When Checking whether Container is Empty, Use empty() instead of Comparing size() with zero", "url": "/posts/use-empty-instread-of-size/", "categories": "C++", "tags": "C++, STL", "date": "2022-01-16 00:00:00 +0900", "snippet": "IntroductionSometimes, programmers would wonder whether use empty() or size() when checking container is empty.Today, I am going to talk about why we should use empty() instead of size().1. Easy to Understand and Type. std::vector&amp;lt;int&amp;gt; v = {1,2,3}; if(0 &amp;lt; v.size()) { //someting.. } std::vector&amp;lt;int&amp;gt; v = {1,2,3}; if(!v.empty()) { //someting.. }There are two kind of code. Which code is more easy to understand and type?empty() function does not use any comparison operators. It is possible to prevent bugs due to incorrect use of comparison operators.(such as If had to use ‘&amp;gt;’ but used ‘&amp;lt;’)Also the code using empty() is easy to understand than size() because it is simpler.Finally, the biggest advantage of using empty() is that it is easy to type.2. empty() is More Faster than size().empty() is implemented as an inline function. also empty() is a constant-time operation for all standard cotainers.whereas some implementations of size() is O(n) time complexity such as list::size().The reason that list::size() has linear time is bacause list container offer splice().in order that size() has constent time complexity, size must be updated whenever every member function operate. It is the same when calling splice(). for updating size, need to count the number of elements to be spliced.So if list::size() must have constent time complexity, splice() time complexity become linear. However, if list::size() doesn’t need to be constent time(doesn’t need to update size), splice() can be a constant time.ConclusionThe reason that use empty() instead of size() is simple. Because empty() is more easier and faster than size(). So call empty whenever you need to know whether a container has zero elements.Referred to Effective STL, vector::empty() and vector::size() in C++ STL" }, { "title": "Making Blog Using Jekyll Chirpy Theme on Windows OS", "url": "/posts/making-blog-using-jekyll-chirpy-theme-on-windows-os/", "categories": "Blogging, Tutorial", "tags": "Blogging", "date": "2022-01-09 00:00:00 +0900", "snippet": "IntroductionAs I started the github blog again, I would like to share the difficulties that I faced while setting up my blog.Among many jekyll themes, I like Chirpy theme the most and I chose this them this time.Other Jekyll themes could be used by fork to their own github repository and only by entering their blog url in _config.yml.but the chirpy theme couldn’t be set up that easily.Fork to Your RepositoryOnce, fork Chirpy theme source code to your github repository. And go to settings then change repository name to [your github id].github.ioIf you have moved the blog code to your repository as above, Now let’s clone it to your local computer.Edit _config.ymlOpen _config.yml file and edit some settings title : Your Blog title. url: Your blog url. (the most important) avatar: your blog avatar image. Installation RubyI install Windows OS version of Ruby because I have Windows OS.After installation ruby, Enter number 3 in console window as below.Move to directory containing blog code and then installation gem dependencies.Installation WSLAfter all gem dependencies are installed, You need to run init.sh script to initialize it.But, Because shell script is only for Linux, You can’t run init.sh directly on Windows. so you have to install WSL(Windows Subsystem for Linux) to run it on Windows.Start -&amp;gt; Turn Windows features on or off -&amp;gt; Check Windows Subsystem for LinuxAnd restart WindowsAnd install Ubuntu in Windows Store and run it.You need to create user. now you can run shell script.Run init.shGo to the directory where your blog source code is stored.Enter the cmd command at windows file explorer address bar.Entering bash command in cmd, shell environment is created.Now, Run init.sh!If you want to know about init.sh, refer to the follow link Chirpy Getting StartedYou need to set up user name and email for git because init.sh use git command when running. If init.sh has run successfully, all you need to is push to your repository.Now, Go to action tab in your repository. you can identify what you have committed is building.It almost done!After build is completed, Go to pages in settings.You need to change branch from master to gh-pages.gh-pages is a branch that is made just after it is built in action tab.It’s done!!Let’s go to your new blog. https://[your github id].github.io From now on, you can upload your post in blog." } ]
